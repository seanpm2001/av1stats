extern crate av1parser;
extern crate clap;

use av1parser as av1p;
use clap::{App, Arg};
use serde::{Deserialize, Serialize};
use std::fs::OpenOptions;
use std::io;
use std::io::{BufReader, LineWriter, Read, Seek, SeekFrom};
use std::vec::Vec;

#[derive(PartialEq)]
enum Output<'a> {
    File(&'a str),
    CommandLine,
}

/// Configuration parameters received via CLI
struct AppConfig<'a> {
    input: &'a str,
    output: Output<'a>,
    verbose: bool,
    append: bool,
    csv: bool,
}

/// Container-level frame data
struct ContainerFrameData {
    /// Size of the frame in bytes
    size: u32,
}

/// AV1 frame types
#[derive(Deserialize, Serialize)]
enum FrameType {
    Key,
    Inter,
    IntraOnly,
    Switch,
}

/// Frame-wise information relevant to AV1 stream analysis
#[derive(Deserialize, Serialize)]
struct FrameData {
    size: u32,
    quantizer_index: u8,
    r#type: FrameType,
}

impl FrameData {
    pub fn new() -> Self {
        FrameData {
            size: 0,
            quantizer_index: 0,
            r#type: FrameType::Key,
        }
    }
}

fn main() -> io::Result<()> {
    /// Shortcut for fetching a Cargo environment variable.
    macro_rules! cargo_env {
        ($name: expr) => {
            env!(concat!("CARGO_PKG_", $name))
        };
    }

    // Define the command line interface.
    let matches = App::new(cargo_env!("NAME"))
        .version(cargo_env!("VERSION"))
        .author(cargo_env!("AUTHORS"))
        .about(cargo_env!("DESCRIPTION"))
        .arg(
            Arg::with_name("input")
                .short("i")
                .long("input")
                .value_name("INPUT_FILE")
                .help("Input filename")
                .required(true)
                .index(1),
        )
        .arg(
            Arg::with_name("output")
                .short("o")
                .long("output")
                .value_name("OUTPUT_FILE")
                .help("Output filename"),
        )
        .arg(
            Arg::with_name("verbose")
                .short("v")
                .long("verbose")
                .help("Prints additional data if writing to the command line"),
        )
        .arg(
            Arg::with_name("append")
                .short("a")
                .long("append")
                .help("Appends the output if writing to file"),
        )
        .arg(
            Arg::with_name("csv")
                .long("csv")
                .help("Processes CSV input generated by previous runs"),
        )
        .get_matches();

    // Parse command line input.
    let config = AppConfig {
        input: matches.value_of("input").unwrap(),
        output: if matches.is_present("output") {
            Output::File(matches.value_of("output").unwrap())
        } else {
            Output::CommandLine
        },
        verbose: matches.is_present("verbose"),
        append: matches.is_present("append"),
        csv: matches.is_present("csv"),
    };

    process_input(&config)?;

    Ok(())
}

#[allow(clippy::cognitive_complexity)]
fn process_input(config: &AppConfig) -> io::Result<()> {
    let input_file = OpenOptions::new()
        .read(true)
        .write(false)
        .open(config.input)
        .expect("could not open the specified input file");

    let mut reader = BufReader::new(input_file);

    let frame_data = if config.csv {
        process_csv(&mut reader)
    } else {
        process_av1(&mut reader)
    }
    .expect("error processing the input");

    match config.output {
        Output::File(fname) => {
            let output_file = OpenOptions::new()
                .write(true)
                .truncate(!config.append)
                .append(config.append)
                .create(true)
                .open(fname)
                .expect("could not open or create the specified output file");

            let mut writer = csv::Writer::from_writer(LineWriter::new(output_file));

            // Write each line of data.
            for frame in frame_data {
                writer.serialize(frame)?;
            }
        }
        Output::CommandLine => {
            if config.verbose {
                let mut writer = csv::Writer::from_writer(io::stdout());

                // Write each line of data.
                for frame in frame_data.iter() {
                    writer.serialize(frame)?;
                }
            }

            let (size_mean, qidx_mean) = (
                frame_data.iter().map(|f| f.size as usize).sum::<usize>() as f64
                    / frame_data.len() as f64,
                frame_data
                    .iter()
                    .map(|f| f.quantizer_index as usize)
                    .sum::<usize>() as f64
                    / frame_data.len() as f64,
            );

            println!(
                "Mean frame size: {:.4}\nMean base quantizer index: {:.4}",
                size_mean, qidx_mean
            );

            let (size_variance, qidx_variance) = (
                frame_data
                    .iter()
                    .map(|f| (f.size as f64 - size_mean).powf(2.0))
                    .sum::<f64>()
                    / frame_data.len() as f64,
                frame_data
                    .iter()
                    .map(|f| (f.quantizer_index as f64 - qidx_mean).powf(2.0))
                    .sum::<f64>()
                    / frame_data.len() as f64,
            );

            println!(
                "Frame size variance: {:.4}\nBase quantizer index variance: {:.4}",
                size_variance, qidx_variance
            );
        }
    }

    Ok(())
}

fn process_av1(reader: &mut BufReader<std::fs::File>) -> Result<Vec<FrameData>, std::io::Error> {
    let fmt = av1p::probe_fileformat(reader).expect("could not probe the input file format");
    reader.seek(SeekFrom::Start(0))?;

    match fmt {
        av1p::FileFormat::IVF => {
            let mut ivf_header = [0; av1parser::ivf::IVF_HEADER_SIZE];
            reader.read_exact(&mut ivf_header)?;

            match av1parser::ivf::parse_ivf_header(&ivf_header) {
                Ok(header) => {
                    if header.codec != av1parser::FCC_AV01 {
                        panic!("unsupport codec");
                    }
                }
                Err(msg) => {
                    panic!("{}", msg);
                }
            }
        }
        _ => unimplemented!("non-IVF input not currently supported"),
    };

    let mut seq = av1p::av1::Sequence::new(); // to be initialized in the parse loop
    let mut frame_data = Vec::new();

    fn get_container_frame<R: io::Read>(
        reader: &mut R,
        fmt: &av1p::FileFormat,
    ) -> Option<ContainerFrameData> {
        match fmt {
            av1p::FileFormat::IVF => {
                if let Ok(frame) = av1p::ivf::parse_ivf_frame(reader) {
                    ContainerFrameData { size: frame.size }.into()
                } else {
                    None
                }
            }
            _ => {
                unreachable!();
            }
        }
    }

    fn process_obu<R: io::Read>(
        reader: &mut R,
        seq: &mut av1p::av1::Sequence,
        obu: &av1p::obu::Obu,
    ) {
        let reader = &mut io::Read::take(reader, u64::from(obu.obu_size));
        if let av1p::obu::OBU_SEQUENCE_HEADER = obu.obu_type {
            if let Some(sh) = av1p::obu::parse_sequence_header(reader) {
                seq.sh = Some(sh);
            }
        }
    }

    // Read one frame from the container at a time.
    while let Some(frame) = get_container_frame(reader, &fmt) {
        let pos = reader.seek(SeekFrom::Current(0))?;
        let mut sz = frame.size;
        let mut seen_frame_header = false;
        let mut frame = FrameData::new();
        frame.size = sz;

        // Read all AV1 OBUs in the container frame.
        while sz > 0 {
            let obu = av1p::obu::parse_obu_header(reader, sz)?;

            sz -= obu.header_len + obu.obu_size;
            let pos = reader.seek(SeekFrom::Current(0))?;

            match obu.obu_type {
                av1p::obu::OBU_FRAME_HEADER | av1p::obu::OBU_FRAME => {
                    if seq.sh.is_some() {
                        if let Some(fh) = av1p::obu::parse_frame_header(
                            reader,
                            seq.sh.as_ref().unwrap(),
                            &mut seq.rfman,
                        ) {
                            if fh.show_frame || fh.show_existing_frame {
                                seq.rfman.output_process(&fh);
                            }
                            if !fh.show_existing_frame {
                                seq.rfman.update_process(&fh);
                            }

                            if !fh.show_existing_frame {
                                seen_frame_header = true;

                                frame.quantizer_index = fh.quantization_params.base_q_idx;
                                frame.r#type = match fh.frame_type {
                                    0 => FrameType::Key,
                                    1 => FrameType::Inter,
                                    2 => FrameType::IntraOnly,
                                    3 => FrameType::Switch,
                                    _ => unreachable!(),
                                };
                            }
                        }
                    } else {
                        panic!("frame header found before sequence header");
                    }
                }
                _ => {
                    process_obu(reader, &mut seq, &obu);
                }
            }

            reader.seek(SeekFrom::Start(pos + u64::from(obu.obu_size)))?;
        }

        reader.seek(SeekFrom::Start(pos + u64::from(frame.size)))?;
        if seen_frame_header {
            frame_data.push(frame);
        }
    }

    Ok(frame_data)
}

fn process_csv(reader: &mut BufReader<std::fs::File>) -> Result<Vec<FrameData>, std::io::Error> {
    let mut csv = csv::Reader::from_reader(reader);
    let mut frame_data = Vec::new();

    for result in csv.deserialize() {
        frame_data.push(result?);
    }

    Ok(frame_data)
}
